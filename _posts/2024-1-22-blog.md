# Remote Code Execution from SSTI in the Sandbox: Automatically Detecting and Exploiting Template Escape Bugs
32nd USENIX Security Symposium (USENIX Security 23), 2023

## Abstract
定义了一种工具，用于检测SSTI的RCE注入漏洞，并且可以不通过学习语法，自动生成POC

## Introduction
* 为了防止SSTI（服务器端模板注入），现代模板引擎（例如Smarty和Twig）提供了沙箱模式
* 核心问题：存在一个漏洞，可以绕过沙箱模式并将 SSTI 攻击提升为 RCE。该漏洞发生在模板渲染过程中。
  PHP模板文件会被渲染转换成 PHP 文件，再被执行。但模板代码可能会因为TE（模板引擎）实现不当，导致PHP代码注入到生成的 PHP 文件中，称为模板逃逸
* 研究目标：生成一个自动工具来检测模板转义错误并评估其可利用性
* 研究面临的难点：
  1. 模板渲染逻辑与语法解析严重交织，难以自动理解和推理
  2. 触发和利用模板转义错误的输入具有语法的高度结构化输入，难以自动化构建
  3. 模板转义错误是语义错误并且难以识别。
* 研究方法：建立了一个基于模糊测试的定制框架 TEFUZZ，利用 PHP 语法指导 PoC 生成、利用覆盖率信息对相似的测试用例进行聚类，以及利用反馈来调整失败的测试用例
  通过收集一组结构良好的模板文件作为种子，TEFUZZ 首先对这些种子进行变异，发现其中潜在的逃逸点，寻找可以利用这些逃逸点来查找 PoC。通过修复生成的 PHP 代码中 PoC 的转义上下文，TEFUZZ 进一步将 PoC 转化为 RCE 漏洞。
* 贡献：
  1. 研究了模板引擎中一个被忽视且严重的沙箱绕过漏洞，并证明了其根本原因。（第二、三章）
  2. 提出了一种自动工具来检测和利用模板转义错误，并引入了几种新技术。（第三、四章）
  3. 在七个 PHP 模板引擎中发现了 135 个错误，并构建了 55 个可实现RCE 攻击的漏洞。（第五章）

## Background
* TE标签：注释（只在模板中使用），变量（定义变量，或者输出转换变量的值），函数（调用TE或模板定义的函数）
* TE类型：基于解释的TE（每个请求都要解析模板并解释标签）和基于生成的TE（将目标转换成PHP文件，并缓存执行该文件，模板被修改则自动更新缓存）
* TE沙盒：禁用危险标签，设置可调用PHP函数的白名单
* 沙箱绕过漏洞：CVE-2021-26120，通过闭合函数名，后执行代码，在函数名处实现SSTI
  本质：输入在转换为PHP代码的过程中逃逸了模板语义
  ![20240122000909.png](/images/1705940267462-0.png)

## Threat Model

* 攻击者的三种SSTI方式
  1. 直接通过输入注入模板
  2. 利用文件上传等漏洞
  3. 滥用web应用程序的正常功能定制模板
* 挑战
  (i) 检测模板转义错误需要进行细粒度分析，以识别模板输入的结构化元素
  (ii) 需要特定的有效负载来触发和利用模板转义错误
  (iii) 缺乏识别模板转义错误和成功利用的预言机。
* 如何检测模板逃逸漏洞：
  1. 平衡探索阶段和利用阶段：两个阶段的技术和用处不同。探索阶段要尽可能识别**存在注入点的测试用例**。开发阶段寻找有效负载，生成POC。
     1. 探索阶段：在模板代码的每个位置**插入一个字符串**，来收集一组新的测试用例。通过收集测试用例对应的每个新生成的 PHP 文件，可以使用该字符串来推断给定测试用例的哪个位置将输出到PHP代码。
     2. 利用阶段：简单的突变策略将导致巨大的测试空间需要探索。但是当有效负载触发模板转义错误时，它也会**破坏生成的 PHP 文件的原始代码结构**。更具体地说，为了破坏 PHP 代码结构，有效负载应**包含 PHP 语言的一些语法字符**（例如“;”和“)”）。因此可以收集这些字符生成POC测试用例。通过观察生成的 PHP 文件的代码结构，可以有效地识别成功的模板逃逸（即错误预言）。
  2. 提高代码覆盖率，同时避免冗余测试。覆盖更多代码对于错误检测很有用，而对类似测试用例的冗余测试会损害模糊测试效率。
     1. 利用错误反馈进行测试用例调整：TE 给出的错误反馈通常会传达有关如何修复失败的测试用例的有用信息，可以被用于半自动测试用例适应技术。
     2. 利用运行时信息进行测试用例聚类：利用阶段会发现使用相同漏洞的类似POC。将代码覆盖率和堆栈跟踪等作为指标，利用运行时信息，在每个阶段对相似的测试用例进行聚类。
* 如何利用模板转义漏洞：在转义模板语义后，畸形的PoC也破坏了生成的PHP文件的原始代码结构，导致无法正常执行。而每个被破坏的 PHP 代码结构都必须以特定的方式修复。
  解决方案：上下文敏感的漏洞利用生成
  1. 识别 PHP 代码中 PoC 的原始上下文：本文总结了模板逃逸的各种原始上下文
  2. 调整 PoC 以保持注入的 PHP 代码适配原始上下文：本文提供了适应 PHP 代码的有效负载调整方法。

## System Design
* TEFUZZ架构
![20240122180439.png](/images/1705940267462-1.png)
* 工作流程：
  1. 种子收集（Seed Collection）：为每个TE收集一组初始测试用例（5.2节）
  2. 可利用用例识别（Interesting Testcase Identification）：提出一种探测技术（4.2.1）来创建大量测试用例，并识别哪些用例可以利用漏洞。如果测试用例运行异常，会通过错误反馈（Testcase Adaption）来调整这些测试用例（4.2.3）。并对这些可利用用例进行聚类。
  3. POC生成（POC Generation）：对于每个可利用用例，使用一种测试用例突变技术（4.2.2），创建许多测试用例，并识别哪些可以用作POC。对于错误的测试用例，使用错误反馈（Testcase Adaption）来调整这些测试用例（4.2.3），并对POC进行进一步的聚类。
  4. 利用综合：对给定的POC，先在生成的PHP文件中，识别其逃逸上下文（Escape Context Identification，4.3.1）。然后调整POC使可攻击的PHP代码包装进POC中（Context-Sensitive Code Wrapping，4.3.2）。
* 测试框架（Testing Framework）：搭建了一个完整的PHP Web应用环境，构建了一个测试用例运行器，在目标TE上运行模板测试用例并收集反馈以促进错误检测和漏洞利用合成。
  测试报告（Testing reports）：对于每个测试用例，测试框架都会返回一个测试报告。
  1. 收集测试期间发生的错误
     1. 板翻译过程中发生的 TE 错误
     2. 生成的PHP文件的执行错误
  2. 收集测试过程中TE覆盖的代码行，用于避免冗余测试
  3. 收集生成的PHP文件，用于识别逃逸点和合成漏洞利用。 

* 可利用用例探测算法：
  1. 在种子测试用例的每个位置插入一个魔术字符串（例如“Un1QuE”）并获得一组新测试用例。
  2. 将每个新的测试用例发送到测试框架模块以获取其测试报告。如果在测试过程中报告了TE错误，则将测试用例发送到测试用例适配模块以尝试修复错误。如果TE错误无法修复，则丢弃该测试用例。
  3. 从测试报告中提取每个测试用例生成的PHP文件，并匹配插入的魔术字符串。如果没有匹配，则丢弃该测试用例。
  4. 收集所有在生成的PHP文件中匹配魔术字符串的测试用例，包括对应的测试报告。
 
  可利用用例聚类规则：类似的可利用用例在模板转换期间应该具有相同的代码占用空间，并且在生成的 PHP 文件中应该具有相同的逃逸上下文。
* POC生成：有效负载应包含一些预定义的 PHP 语法字符，例如“;”和“)”。
  测试用例突变流程：
  1. 所有预定义的 PHP 语法字符。此外，我们还包括一些其他常见的转义字符，共134个转义字符。
  2. 将这些转义字符插入到可利用用例的每个逃逸上下文中，以创建新的测试用例
  3. 运行每个新的测试用例，用错误反馈来修复测试期间报告的 TE 错误。
  4. 使用生成的 PHP 文件作为预言机来识别 PoC。尤其是，如果生成的PHP文件在模板渲染过程中报告PHP错误或其原始代码结构发生变化，将测试用例视为PoC。
   
  POC聚类规则：根据 PoC 的代码覆盖率和逃逸上下文进行聚类。
  1. 给定两个 PoC，首先使用它们覆盖的代码行号之间的 Jaccard 索引来测量覆盖相似度。
  2. 然后使用包含逃逸上下文的 PHP 代码行之间的编辑距离来测量逃逸上下文相似度
  3. 为了减少误报，使用保守的设计，设置了一个0.95的高阈值，只有覆盖相似度和逃逸上下文相似度都超过阈值时，才被识别为相同。
* 用例适应反馈：修复失败的测试用例以提高测试覆盖率。**手动**收集测试过程中可能报告的错误消息，并编译相应的适配规则来修复测试用例。
  三种TE错误：文件错误、语法错误和属性错误。
  修复方案：当单轮适应无法修复测试用例时，我们将重复适应，直到适应的总轮数达到给定限制
  1. 文件适应：测试用例会引用一些文件，如果文件不存在或者没有权限，则创建该文件或者增加权限
  2. 语法适应：i）缺少参数或属性，ii）未封闭的符号，以及 iii）未封闭的标签。匹配错误并修复他们
  3. 属性适应：突变可能会破坏某些标签属性的值，使其类型不满足要求。对于此类错误，则更改值，直到它们变得合法。
* 逃逸上下文识别：
  五种不同的逃逸上下文：通过在生成的 PHP 文件的抽象语法树 (AST) 中定位 PoC 的逃逸点来识别 PoC 的逃逸上下文。
  1. 函数/类定义：在定义某些 PHP 函数或类时，TE可能会使用模板代码元素对其进行命名。
  2. 函数调用语句：模板代码元素可用于在函数调用语句中引用 PHP 函数或其参数。
  3. 赋值语句：TE 通常使用模板代码元素来生成赋值语句，例如在翻译变量标签时。
  4. 条件语句：模板代码中定义的变量可能会出现在生成的 PHP 文件的一些条件语句中，例如 if 语句、foreach 语句。
  5. 注释：TE 通常会使用模板代码的某些元素在 PHP 文件中生成注释。
   
  当 PoC 触发模板转义错误时，它会破坏 PHP 文件的正确代码结构，从而使定位逃逸点变得非常困难。因此，我们使用良性输入来替换 PoC 的恶意输入负载，然后生成有效的 PHP 文件。通过在有效的AST中定位良性输入的节点，我们识别出该节点所属的PHP语句以及基于该PHP语句的逃逸上下文。
* 上下文敏感代码包装：基于模板的方法为每个 PoC 生成正确的包装有效负载。
  1. 根据逃逸上下文和逃逸点，我们寻找正确的有效负载来关闭当前的 PHP 语句。整体策略就像一个switch case，即以逃逸上下文和逃逸点为关键，找到相应的模板来生成有效负载。
  2. 包装完逃逸点之前的代码后，我们找到逃逸点后面代码的 AST 节点，将其闭合。关闭这些节点的一个直接方法是将它们放入注释中。在大多数情况下，可以使用有效负载“//”将代码包装在EP之后。但是，当剩余代码跨越多行时，行注释无法包装所有代码。因此要采用与上一步相同的策略来寻找可以将剩余代码转换为有效 PHP 语句的有效负载。具体来说，我们根据当前PHP语句的逃逸上下文和逃逸点定义了几个payload生成模板。例如，如果逃逸上下文是一个PHP函数定义语句，我们可以使用“function”来关闭剩余的代码。
  3. 使用上述两个有效负载将代码包装在逃逸上下文周围，我们在有效负载之间插入目标 RCE 代码。
## Evaluation
* TEFUZZ原型：由 4300 行 Python 代码和 560 行 PHP 代码组成。种子收集模块是使用 Python requests 包构建的。测试框架模块搭建在PHP版本为7.2.34的Apache Web服务器上。测试过程中使用Xdebug 7收集被测TE的代码覆盖率。 Bug 检测模块和 Exploit Synthesis 模块都是用 Python 实现的。这两个模块的执行方式都是将测试用例发送到测试框架模块并分析返回的测试报告。
* TE数据集选择：选择基于生成的TE，选择知名的TE，选择有沙箱或者拒绝支持在模板中执行PHP的TE。最终收集了7个符合标准的TE：，Smarty、Latte、Dwoo、Fenom、Twig、Mustache和ThinkPHP
  配置TE：
  1. 为每个 TE 手动创建一个驱动程序，以支持在测试框架模块中测试其模板测试用例，并开启沙箱模式
  2. 提取了每个 TE 使用的分隔符，用于种子收集模块和测试用例适应模块
  3. 根据测试过程中报告的错误信息，在用例适应反馈模块中**手动**编译了适应规则来修复这些错误。
![20240122212207.png](/images/1705940267462-2.png)
* 种子收集：
  1. 对每个TE，使用爬虫收集其官方文档和源代码中的测试文件
  2. 根据分隔符编写正则表达式，从爬取的文本中提取模板代码
  
  结果：收集了2527个模板测试用例的初始语料库，有1621个测试用例可以正常运行。对报告错误的906个案例，使用用例适应反馈模块修复了107个案例
* 实验尝试回答的问题：
  1. 模板转义错误有多普遍？
  2. 模板转义错误有多严重？
  3. TEFUZZ 与 其他SSTI扫描工具相比如何？
  4. 在实际应用程序中利用模板转义错误的可行性如何？
  5. TEFUZZ 的内部设计有多大帮助？
* 模板逃逸错误的普遍性和严重性：产生漏洞结果如图，**135个转义错误**，**55个可利用漏洞**
![20240122224317.png](/images/1705940267462-3.png)
  产生漏洞的原因：
  1. 模板代码解析中的验证不完整，比如允许一些特殊符号作为变量名的一部分
  2. PHP 代码生成中的清理不完整：在TE进行代码清理，用于防止PHP语法逃逸的过程中，没有正确执行清理，或者遗漏清理某些字符。
  
  TE的四个特征更容易出现模板转义错误：
  1. 复杂的模板语法
  2. 将模板变量直接映射到PHP 变量
  3. 乐观的模板代码解析
  4. 缺乏对生成的PHP 代码的清理
* 与其他SSTI扫描工具对比： tplmap 成功发现了每个 TE 的应用程序驱动程序中的模板注入点。然而，由于无法生成新的沙箱绕过有效负载，tplmap 无法绕过任何 TE 的沙箱。相比之下，使用 TEFUZZ 生成的 RCE 有效负载，tplmap 成功破坏了每个 TE（Twig 除外）的沙箱。
  ![20240122230454.png](/images/1705940267462-4.png)
* 实际利用的可行性：研究已知漏洞的数据库+发现一些 0-day SSTI 
  1. 收集了一组模板注入漏洞：在CVE数据库搜索关键词，得到145条搜索结果，经过**人工**检查确定了80个SSTI漏洞，并定位了产生原因，发现了45个漏洞属于直接模板代码注入，8个漏洞属于利用其他类型的漏洞，25个漏洞属于滥用 Web 应用程序的某些正常功能。
  2. 已知SSTI漏洞的充分利用：检查收集的 SSTI 漏洞是否可以帮助已发现的模板转义漏洞实现完整的 RCE 利用。采用两种方法来确认SSTI漏洞所使用的TE：1）检查受影响的Web应用程序的源代码和2）阅读该应用程序的官方网站的描述。
    在转义漏洞数据集比较，发现了CVE数据库中三个使用易受攻击的TE的漏洞，和安全报告中另外两个TE漏洞，可以结合TEFUZZ合成的 RCE 有效负载，实现 RCE 攻击。
    示例：CVE-2020-15906和CVE-2017-6070，都是在沙箱模式运行下可以防御，但经过TEFUZZ产生的payload，绕过了沙箱的防御，扩大了 SSTI 漏洞的攻击能力。
  3. 发现0day漏洞
     1. 收集PHP应用数据集（CMS）：找到了 18 个使用易受攻击的 TE 的 PHP 应用程序。多数应用程序都使用了 Smarty。搭建对应的最新环境。
     ![20240122232247.png](/images/1705940267462-5.png)
     2. 首先使用Crawlergo+tplmap扫描：没有扫出漏洞
     3. 人工挖掘：发现了6个应用程序漏洞
     ![20240122232546.png](/images/1705940267462-6.png)
* TEFUZZ 的内部结果：
  1. 测试用例探测：基于收集的1728个种子，TEFUZZ创建了64491个新测试用例，同时发现其中36540个测试用例包含逃逸点。经过聚类，TEFUZZ 进一步识别出 4484 个（12.3％）可利用测试用例。
  2. POC生成：基于发现的 4,484 个可利用测试用例，TEFUZZ 创建了 546,893 个新测试用例来发现错误，总共发现了 661 个触发错误的 PoC。
  ![20240122233005.png](/images/1705940267462-7.png)
  3. POC聚类：TEFUZZ 自动对 170个独特的 PoC进行聚类。我们手动分析了这些 PoC，并确认了135个有效，为了了解 PoC 聚类的误报，从663个PoC中随机选择了200个案例进行手动验证。我们发现 TEFUZZ 从未将独特的 PoC 识别为相同的（即**零假阴性率**）。
  4. 测试用例适应：在 64,491 个测试用例中遇到了TE错误，并成功修复了44,103个用例（修复率：69.4%）
  ![20240122232813.png](/images/1705940267462-8.png) 
  两种无法修复的情况：a.有些错误无法修复（比如TE不支持）b.错误消息没有传达足够的修复信息
  种子收集模块中的修复率最低（比如某些测试用例需要第三方插件；一些测试用例在沙盒模式下使用禁止标签），PoC Generation模块报告的修复率最高（TE错误大多是由类似的原因引起的，并且更容易建模和修复）。
  测试用例适应效果：如图所示，测试用例适应帮助收集了6.7%的种子，发现了21.6%的错误，并合成了 31.0%的漏洞。
  ![20240123000432.png](/images/1705940267462-9.png)
  5. 漏洞利用合成：在135个合成漏洞中，有80个无法在测试框架中运行。
     错误原因：
     1. 模板解析错误（58 例）：用于将转义上下文包装在PHP文件中的有效负载会使 TE 无法解析模板代码。
     2. 模板验证错误（22 例）：TE正确解析了合成的漏洞利用；但在检查已解析元素的格式时，它会引发 TE 错误
## Discussion
* 问题范围：只限于SSTI，没有扩展到其他绕过沙箱。此外其他语言的项目也可以验证
* 技术限制：无法检测种子语料库中那些未覆盖的模板标签/语法的错误；在生成 PoC 和漏洞利用过程中没有考虑 TE 中的控制/数据流约束，这可能会错过一些真正的错误和漏洞利用。
* 不可利用的漏洞：没有人工适配运行失败的POC去实现RCE。
## 个人评价
1. 实验目标很清楚，evaluation部分非常详细，五个问题对应五个章节，每一个情况都给出了原因解释。
2. 研究重点是绕过沙箱模式，也就是如果原有漏洞只是通过沙箱进行防御的，可以实现效果很好的绕过
3. 理论部分较为简单，第三章和第四组有些地方重复。
4. 文章脉络比较清晰，系统流程很完整。
5. 只能够挖掘模板本身的漏洞，无法自动化的和CMS结合输入，实现0day的挖掘或者1day的复现。都是手工实现的，无法自动化的挖掘。以至于最后POC失败率较高。
6. 启发：fuzz的用于输入，如果与大模型结合去进行输出评价和自动化调整，会不会实现更自动化的挖掘。